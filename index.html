<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Palopsee's Space Run</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Pixelify+Sans:wght@400;600;700&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            font-family: 'Pixelify Sans', 'Inter', sans-serif; 
            margin: 0;
            color: #333; 
            overscroll-behavior-y: contain; 
            transition: background-color 0.3s ease, color 0.3s ease;
            overflow: hidden; 
            height: 100vh; 
            width: 100vw;
        }
        #backgroundCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%; 
            height: 100%;
            z-index: -1; 
        }
        #headerLinkContainer {
            position: fixed; 
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10; 
        }
        #headerPalopseeCanvas {
            border-radius: 4px; 
            cursor: pointer;
        }
        canvas#gameCanvas { 
            position: fixed;
            top: 0;
            left: 0;
            width: 100%; 
            height: 100%;
            touch-action: none; 
            display: block; 
            z-index: 0; 
        }
        #messageBox {
            position: fixed;
            top: 80px; 
            left: 50%;
            transform: translateX(-50%);
            background-color: #4A90E2; 
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000; 
            display: none; 
            font-size: 16px;
            font-family: 'Pixelify Sans', 'Inter', sans-serif; 
        }
        .light-theme {
            background-color: #ffffff; 
            color: #333333;
        }
        .dark-theme {
            background-color: #121212; 
            color: #DDDDDD;
        }

        #theme-toggle {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 1001;
            cursor: pointer;
            background-color: rgba(128, 128, 128, 0.2);
            border-radius: 50%;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
        }
        #theme-toggle:hover {
            background-color: rgba(128, 128, 128, 0.4);
        }
        #theme-toggle svg {
            width: 24px;
            height: 24px;
        }
        .light-theme #sun-icon { display: none; }
        .light-theme #moon-icon { display: block; fill: #333; }
        .dark-theme #sun-icon { display: block; fill: #FFF; }
        .dark-theme #moon-icon { display: none; }
    </style>
</head>
<body>

    <canvas id="backgroundCanvas"></canvas>

    <div id="headerLinkContainer">
        <a id="headerLink" href="#" target="_blank" rel="noopener noreferrer">
            <canvas id="headerPalopseeCanvas"></canvas>
        </a>
    </div>

    <canvas id="gameCanvas"></canvas> 

    <div id="messageBox"></div>

    <div id="theme-toggle" title="Toggle Theme">
        <svg viewBox="0 0 24 24">
            <path id="moon-icon" d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path>
            <path id="sun-icon" d="M12 3a1 1 0 011 1v2a1 1 0 11-2 0V4a1 1 0 011-1zM4.929 4.929a1 1 0 011.414 0l1.414 1.414a1 1 0 01-1.414 1.414L4.929 6.343a1 1 0 010-1.414zM21 12a1 1 0 01-1 1h-2a1 1 0 110-2h2a1 1 0 011 1zM16.243 16.243a1 1 0 011.414 0l1.414 1.414a1 1 0 01-1.414 1.414l-1.414-1.414a1 1 0 010-1.414zM12 19a1 1 0 011 1v2a1 1 0 11-2 0v-2a1 1 0 011-1zM7.757 16.243a1 1 0 010 1.414l-1.414 1.414a1 1 0 01-1.414-1.414l1.414-1.414a1 1 0 011.414 0zM4 12a1 1 0 01-1 1H1a1 1 0 110-2h2a1 1 0 011 1zM7.757 7.757a1 1 0 010-1.414L6.343 4.929a1 1 0 111.414-1.414l1.414 1.414a1 1 0 01-1.414 1.414zM12 7a5 5 0 100 10 5 5 0 000-10z"></path>
        </svg>
    </div>


    <script>
        const gameCanvas = document.getElementById('gameCanvas');
        const ctx = gameCanvas.getContext('2d');
        const backgroundCanvas = document.getElementById('backgroundCanvas');
        const bgCtx = backgroundCanvas.getContext('2d'); 

        const headerPalopseeCanvas = document.getElementById('headerPalopseeCanvas');
        const headerPalopseeCtx = headerPalopseeCanvas.getContext('2d');
        const headerLink = document.getElementById('headerLink');

        const messageBox = document.getElementById('messageBox');
        const bodyElement = document.body;
        const themeToggle = document.getElementById('theme-toggle');

        // --- Sound Effects Setup ---
        let audioInitialized = false;
        let jumpSynth, scoreSynth, gameOverSynth, powerUpSynth;

        function initializeAudio() {
            if (Tone.context.state !== 'running') Tone.start();
            jumpSynth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.01, release: 0.1 } }).toDestination();
            scoreSynth = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.05, sustain: 0, release: 0.1 } }).toDestination();
            gameOverSynth = new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.1 } }).toDestination();
            powerUpSynth = new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 } }).toDestination();
            audioInitialized = true;
        }
        
        function playJumpSound() { if (audioInitialized) {jumpSynth.volume.value = -12; jumpSynth.triggerAttackRelease('C5', '8n', Tone.now());} }
        function playScoreSound() { if (audioInitialized) {scoreSynth.volume.value = -18; scoreSynth.triggerAttackRelease('A5', '16n', Tone.now());} }
        function playGameOverSound() { if (audioInitialized) {gameOverSynth.volume.value = -8; gameOverSynth.triggerAttackRelease('16n', Tone.now());} }
        function playPowerUpSound() { if (audioInitialized) {powerUpSynth.volume.value = -10; powerUpSynth.triggerAttackRelease('G5', '8n', Tone.now());} }

        // --- Theme Colors ---
        const themes = {
            light: { bodyBg: '#ffffff', bodyText: '#333333', canvasFallbackBg: '#ffffff', scoreText: '#333333', promptText: '#000000', promptBg: 'rgba(255, 255, 255, 0.7)', gameOverOverlay: 'rgba(0, 0, 0, 0.75)', gameOverMainText: '#FFFFFF', gameOverSubText: '#FFFFFF' },
            dark: { bodyBg: '#121212', bodyText: '#DDDDDD', canvasFallbackBg: '#222222', scoreText: '#DDDDDD', promptText: '#FFFFFF', promptBg: 'rgba(0, 0, 0, 0.5)', gameOverOverlay: 'rgba(255, 255, 255, 0.15)', gameOverMainText: '#FFFFFF', gameOverSubText: '#EEEEEE' }
        };
        let currentTheme = themes.light; 
        let isDarkMode = false; 

        // --- Customizable Link URL ---
        let customHeaderLinkUrl = "https://palopsee.univer.se/"; 
        
        // --- NEW: Game Scaling Constants ---
        const PLAYER_SCALE_HEIGHT = 44;     // Base height for the player, similar to Chrome Dino
        const OBSTACLE_SCALE_HEIGHT = 42;   // Base height for obstacles
        const POWERUP_SCALE_HEIGHT = 28;    // Base height for power-ups
        const HEADER_ICON_SIZE = 40;        // Explicit size for header icon
        const BACKGROUND_TILE_WIDTH = 200;
        const BACKGROUND_TILE_HEIGHT = 150;
        
        // --- Asset URLs ---
        const imageUrls = {
            palopsee: 'https://palopsee.netlify.app/palopsee.png',
            background: 'https://palopsee.netlify.app/background.png',
            alienShip: '/alien1.png',
            powerUp: '/star1.png'
        };
        const gifUrls = {
            asteroid: '/asteroid1.gif'
        };

        // --- Asset Manager (Stores natural dimensions) ---
        const assetManager = {
            assets: {},
            totalAssets: 0,
            loadedAssets: 0,
            onAllAssetsLoaded: null,

            loadAsset(name, src) {
                this.totalAssets++;
                const asset = new Image();
                this.assets[name] = { image: asset, width: 0, height: 0 };
                asset.onload = () => {
                    console.log(`Loaded ${name} (${asset.naturalWidth}x${asset.naturalHeight})`);
                    this.assets[name].width = asset.naturalWidth;
                    this.assets[name].height = asset.naturalHeight;
                    this.assetLoaded();
                };
                asset.onerror = () => {
                    console.error(`Failed to load asset: ${name} at ${src}`);
                    this.assetLoaded();
                };
                asset.src = src;
            },
            assetLoaded() {
                this.loadedAssets++;
                if (this.loadedAssets === this.totalAssets && typeof this.onAllAssetsLoaded === 'function') {
                    this.onAllAssetsLoaded();
                }
            },
            get(name) {
                return this.assets[name];
            }
        };

        let bgPatternCanvas = null; 
        let backgroundPattern = null; 
        let backgroundOffsetX = 0; 
        
        // Game variables
        const highScoreKey = 'palopseeGameHighScore'; 
        let score = 0;
        let previousScoreForSound = 0; 
        const scoreMilestoneInterval = 30; 
        let powerUpSpawnedForCurrentMilestone = false; 
        let highScore = 0;
        let gameSpeed = 5;
        let gameSpeedIncreaseFactor = 0.002;
        let gameOver = false;
        let gameStarted = false;
        let assetsReady = false;
        let animationFrameId;

        let gameCanvasWidth; 
        let gameCanvasHeight; 

        const gameFont = "'Pixelify Sans', 'Inter', sans-serif"; 

        const player = {
            x: 50, y: 0, width: 0, height: 0, // Dimensions will be set dynamically based on scale
            dy: 0, jumpStrength: 12, gravity: 0.7,   
            isJumping: false, restingY: 0, isInvincible: false, invincibilityFrames: 0, 
            draw() {
                const palopseeAsset = assetManager.get('palopsee');
                if (!palopseeAsset || !palopseeAsset.image.complete) return;

                ctx.save();
                if (isDarkMode) {
                    ctx.filter = 'invert(1) hue-rotate(180deg) brightness(1.1) contrast(1.1)';
                }
                
                if (this.isInvincible && this.invincibilityFrames++ % 10 < 5) {
                    // Flicker effect
                } else {
                    ctx.drawImage(palopseeAsset.image, this.x, this.y, this.width, this.height);
                }
                
                ctx.restore();
            },
            jump() {
                if (!this.isJumping && !gameOver && gameStarted) { 
                    this.isJumping = true;
                    this.dy = -this.jumpStrength;
                    playJumpSound(); 
                }
            },
            update() {
                if (this.isJumping) {
                    this.y += this.dy;
                    this.dy += this.gravity;
                }
                if (this.y >= this.restingY && this.dy > 0) {
                    this.y = this.restingY;
                    this.isJumping = false;
                    this.dy = 0;
                }
            }
        };

        let obstacles = [];
        let powerUps = []; 

        /**
         * Calculates scaled dimensions for an asset while maintaining aspect ratio.
         * @param {string} assetName - The name of the asset in the assetManager.
         * @param {number} baseHeight - The target height to scale to.
         * @returns {{width: number, height: number}} - The new scaled dimensions.
         */
        function getScaledDimensions(assetName, baseHeight) {
            const assetInfo = assetManager.get(assetName);
            if (!assetInfo || !assetInfo.height) { // Check height to avoid division by zero
                return { width: baseHeight, height: baseHeight }; // Return a default square if asset fails
            }
            const aspectRatio = assetInfo.width / assetInfo.height;
            const scaledWidth = baseHeight * aspectRatio;
            return { width: scaledWidth, height: baseHeight };
        }

        function createObstacle() {
            const isAsteroid = Math.random() < 0.6;
            const assetName = isAsteroid ? 'asteroid' : 'alienShip';
            const assetInfo = assetManager.get(assetName);
            
            if (!assetInfo || assetInfo.width === 0) return; // Don't create if asset not loaded

            const scaledDims = getScaledDimensions(assetName, OBSTACLE_SCALE_HEIGHT);
            const verticalCenter = gameCanvasHeight / 2;
            let yPos;

            if (isAsteroid) {
                yPos = verticalCenter - scaledDims.height / 2 + (Math.random() * player.height - player.height / 2);
            } else { 
                const alienShipClearance = 10;
                yPos = player.restingY - alienShipClearance - scaledDims.height;
                if (yPos < 10) yPos = 10;
            }

            obstacles.push({ 
                x: gameCanvasWidth, y: yPos, 
                width: scaledDims.width, height: scaledDims.height, 
                image: assetInfo.image, 
                draw() { 
                    if (this.image && this.image.complete) {
                        ctx.drawImage(this.image, this.x, this.y, this.width, this.height); 
                    }
                }, 
                update() { this.x -= gameSpeed; } 
            });
        }

        function createPowerUp() {
            const assetInfo = assetManager.get('powerUp');
            if (!assetInfo || assetInfo.width === 0) return;

            const scaledDims = getScaledDimensions('powerUp', POWERUP_SCALE_HEIGHT);
            const verticalCenter = gameCanvasHeight / 2;
            const yPos = verticalCenter - scaledDims.height / 2 + (Math.random() * (player.height * 2) - player.height);
            
            const newPowerUp = {
                x: gameCanvasWidth, y: yPos,
                width: scaledDims.width, height: scaledDims.height,
                image: assetInfo.image,
                draw() { 
                     if (this.image && this.image.complete) {
                        ctx.drawImage(this.image, this.x, this.y, this.width, this.height); 
                     }
                },
                update() { this.x -= gameSpeed; }
            };
            if (newPowerUp.y < 20) newPowerUp.y = 20;
            if (newPowerUp.y + newPowerUp.height > gameCanvasHeight - 20) newPowerUp.y = gameCanvasHeight - 20 - newPowerUp.height;
            powerUps.push(newPowerUp);
        }

        function handleObstacles() {
            const spawnMinDistance = gameCanvasWidth * 0.4 + gameSpeed * 10; 
            const spawnRandomDistance = gameCanvasWidth * 0.3;

            if (obstacles.length === 0 || obstacles[obstacles.length - 1].x < gameCanvasWidth - spawnMinDistance - Math.random() * spawnRandomDistance) {
                 if (Math.random() < (0.015 + gameSpeed * 0.0005) && gameStarted) { 
                    createObstacle();
                 }
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                obs.update();
                obs.draw();

                if ( !player.isInvincible && player.x < obs.x + obs.width && player.x + player.width > obs.x && player.y < obs.y + obs.height && player.y + player.height > obs.y) {
                    setGameOver();
                    return; 
                }

                if (obs.x + obs.width < 0) {
                    obstacles.splice(i, 1);
                    if (!gameOver) {
                        score++;
                        if (score > 0 && score % scoreMilestoneInterval === 0 && score !== previousScoreForSound) {
                            playScoreSound();
                            previousScoreForSound = score; 
                        }
                        if (score % scoreMilestoneInterval !== 0) powerUpSpawnedForCurrentMilestone = false;
                    }
                }
            }
        }

        function handlePowerUps() {
            if (gameStarted && powerUps.length === 0 && score > 0 && score % scoreMilestoneInterval === 0 && !powerUpSpawnedForCurrentMilestone) {
                createPowerUp();
                powerUpSpawnedForCurrentMilestone = true; 
            }

            for (let i = powerUps.length - 1; i >= 0; i--) {
                const pUp = powerUps[i];
                pUp.update();
                pUp.draw();

                if (player.x < pUp.x + pUp.width && player.x + player.width > pUp.x && player.y < pUp.y + pUp.height && player.y + player.height > pUp.y) {
                    player.isInvincible = true;
                    player.invincibilityFrames = 0; 
                    playPowerUpSound();
                    powerUps.splice(i, 1); 
                    setTimeout(() => { player.isInvincible = false; }, 5000); 
                }

                if (pUp.x + pUp.width < 0) powerUps.splice(i, 1);
            }
        }
        
        function createBackgroundPatternTile() {
            const bgInfo = assetManager.get('background');
            if (bgInfo && bgInfo.image.complete) {
                bgPatternCanvas = document.createElement("canvas");
                bgPatternCanvas.width = BACKGROUND_TILE_WIDTH;
                bgPatternCanvas.height = BACKGROUND_TILE_HEIGHT;
                const patternCtx = bgPatternCanvas.getContext("2d");
                patternCtx.drawImage(bgInfo.image, 0, 0, bgPatternCanvas.width, bgPatternCanvas.height);
                createActualPattern();
            } else {
                bgPatternCanvas = null;
            }
        }
        
        function createActualPattern(){ 
            if (bgPatternCanvas && bgCtx) backgroundPattern = bgCtx.createPattern(bgPatternCanvas, "repeat");
            else backgroundPattern = null;
        }

        function drawScrollingFullScreenBackground(){ 
            if (!bgCtx) return;
            bgCtx.clearRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
            
            if (backgroundPattern && bgPatternCanvas) {
                bgCtx.save();
                bgCtx.globalAlpha = 0.1;
                let patternOffsetX = backgroundOffsetX % bgPatternCanvas.width;
                bgCtx.translate(patternOffsetX, 0);
                bgCtx.fillStyle = backgroundPattern;
                bgCtx.fillRect(-patternOffsetX, 0, backgroundCanvas.width + bgPatternCanvas.width, backgroundCanvas.height); 
                bgCtx.restore();
            } else {
                bgCtx.fillStyle = currentTheme.canvasFallbackBg;
                bgCtx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
            }
        }
        
        function showMessage(msg, duration = 3000) {
            messageBox.textContent = msg;
            messageBox.style.display = "block";
            setTimeout(() => { messageBox.style.display = "none" }, duration);
        }
        
        function drawHeaderPalopsee() {
            if (!headerPalopseeCtx) return;
            const palopseeAsset = assetManager.get('palopsee');
            headerPalopseeCanvas.width = HEADER_ICON_SIZE;
            headerPalopseeCanvas.height = HEADER_ICON_SIZE;
            headerPalopseeCtx.clearRect(0, 0, HEADER_ICON_SIZE, HEADER_ICON_SIZE);

            if (palopseeAsset && palopseeAsset.image.complete) {
                headerPalopseeCtx.save();
                if (isDarkMode) {
                     headerPalopseeCtx.filter = 'invert(1) hue-rotate(180deg) brightness(1.1) contrast(1.1)';
                }
                headerPalopseeCtx.drawImage(palopseeAsset.image, 0, 0, HEADER_ICON_SIZE, HEADER_ICON_SIZE);
                headerPalopseeCtx.restore();
            }
        }

        function setGameOver() {
            gameOver = true;
            gameStarted = false;
            player.isInvincible = false; 
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            playGameOverSound(); 
            
            ctx.fillStyle = currentTheme.gameOverOverlay; 
            ctx.fillRect(0, 0, gameCanvasWidth, gameCanvasHeight); 
            ctx.font = `40px ${gameFont}`; 
            ctx.fillStyle = currentTheme.gameOverMainText; 
            ctx.textAlign = 'center';
            ctx.fillText('Game Over!', gameCanvasWidth / 2, gameCanvasHeight / 2 - 30);
            ctx.font = `20px ${gameFont}`; 
            ctx.fillStyle = currentTheme.gameOverSubText; 
            ctx.fillText(`Score: ${score}`, gameCanvasWidth / 2, gameCanvasHeight / 2 + 10);
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem(highScoreKey, highScore); 
                ctx.fillText(`New High Score! ${highScore}`, gameCanvasWidth / 2, gameCanvasHeight / 2 + 40);
            } else {
                ctx.fillText(`High Score: ${highScore}`, gameCanvasWidth / 2, gameCanvasHeight / 2 + 40);
            }
            ctx.font = `16px ${gameFont}`; 
            ctx.fillText('Tap or Press Space/Up to Restart', gameCanvasWidth / 2, gameCanvasHeight / 2 + 70);
        }

        function resetGame() {
            score = 0;
            previousScoreForSound = 0; 
            powerUpSpawnedForCurrentMilestone = false; 
            gameSpeed = 5; 
            gameOver = false;
            gameStarted = false; 
            obstacles = [];
            powerUps = []; 
            player.dy = 0;
            player.isJumping = false;
            player.isInvincible = false;
            
            resizeAndRedrawAll();
            messageBox.style.display = 'none';
        }
        
        function gameLoop() {
            if (gameOver) return;

            backgroundOffsetX -= gameSpeed;
            drawScrollingFullScreenBackground(); 

            ctx.clearRect(0, 0, gameCanvasWidth, gameCanvasHeight); 
            
            if (gameStarted) {
                player.update();
                handleObstacles(); 
                handlePowerUps();
                gameSpeed += gameSpeedIncreaseFactor;
            }
            
            player.draw();
            obstacles.forEach(obs => obs.draw());
            powerUps.forEach(pUp => pUp.draw());

            ctx.font = `16px ${gameFont}`; 
            ctx.fillStyle = currentTheme.scoreText; 
            ctx.textAlign = 'left';
            ctx.fillText(`Score: ${score}`, 10, 25);
            ctx.fillText(`High Score: ${highScore}`, 10, 50);

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function assetsReadyCallback() {
            assetsReady = true;

            const scaledPlayerDims = getScaledDimensions('palopsee', PLAYER_SCALE_HEIGHT);
            player.width = scaledPlayerDims.width;
            player.height = scaledPlayerDims.height;
            
            createBackgroundPatternTile();
            drawHeaderPalopsee();
            resizeAndRedrawAll(); 
            
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop();
            
            if (!gameStarted && !gameOver) showMessage('Ready to Fly!', 2000);
        }

        function startGameActions(event) {
            if (event && event.target.closest('#theme-toggle')) return;
            if (!audioInitialized) initializeAudio();
            if (gameOver) { resetGame(); return; }
            if (!gameStarted && assetsReady) {
                gameStarted = true;
                score = 0;
                gameSpeed = 5;
                player.jump();
            } else if (gameStarted) {
                 player.jump();
            }
        }

        window.addEventListener('keydown', (e) => { if ((e.code === 'Space' || e.code === 'ArrowUp')) { e.preventDefault(); startGameActions(e); } });
        document.body.addEventListener('touchstart', (e) => {
            if (e.target.closest('#headerLinkContainer')) return; 
            e.preventDefault(); 
            startGameActions(e); 
        }, { passive: false }); 

        function applyTheme(isDark) { 
            isDarkMode = isDark; 
            currentTheme = isDarkMode ? themes.dark : themes.light; 
            bodyElement.className = isDarkMode ? 'dark-theme' : 'light-theme'; 
            drawHeaderPalopsee();
        }

        themeToggle.addEventListener('click', () => applyTheme(!isDarkMode));

        function resizeAndRedrawAll() { 
            backgroundCanvas.width = window.innerWidth;
            backgroundCanvas.height = window.innerHeight;
            gameCanvas.width = window.innerWidth;
            gameCanvas.height = window.innerHeight;
            gameCanvasWidth = gameCanvas.width; 
            gameCanvasHeight = gameCanvas.height;

            player.restingY = gameCanvasHeight / 2 - player.height / 2;
            if (!player.isJumping || !gameStarted) {
                 player.y = player.restingY;
            }
            
            createBackgroundPatternTile();
            drawHeaderPalopsee();

            if (!gameStarted && assetsReady) { 
                ctx.font = `20px ${gameFont}`; 
                ctx.textAlign = 'center';
                const promptText = 'Tap Screen or Press Space/Up to Start!';
                const textMetrics = ctx.measureText(promptText);
                ctx.fillStyle = currentTheme.promptBg; 
                ctx.fillRect(gameCanvas.width / 2 - textMetrics.width / 2 - 10, gameCanvas.height - 80, textMetrics.width + 20, 30);
                ctx.fillStyle = currentTheme.promptText; 
                ctx.fillText(promptText, gameCanvas.width / 2, gameCanvas.height - 60);
            }
        }
        
        window.addEventListener('resize', resizeAndRedrawAll);

        function initGame() {
            headerLink.href = customHeaderLinkUrl; 
            const savedHighScore = localStorage.getItem(highScoreKey);
            if (savedHighScore) highScore = parseInt(savedHighScore, 10);

            assetManager.onAllAssetsLoaded = assetsReadyCallback;
            
            Object.keys(imageUrls).forEach(name => assetManager.loadAsset(name, imageUrls[name]));
            Object.keys(gifUrls).forEach(name => assetManager.loadAsset(name, gifUrls[name]));

            const darkModeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
            applyTheme(darkModeMediaQuery.matches); 
        }

        initGame(); 
    </script>
</body>
</html>
