<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Palopsee's Space Run</title>
    <link rel="icon" href="https://palopsee.netlify.app/palopsee.png">
    <link href="https://fonts.googleapis.com/css2?family=Pixelify+Sans:wght@400;600;700&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Pixelify Sans', 'Inter', sans-serif; 
            margin: 0;
            background-color: #ffffff; 
            color: #333333; 
            overscroll-behavior-y: contain; 
            overflow: hidden; 
            height: 100vh; 
            width: 100vw;
        }
        #backgroundCanvas, #gameCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%; 
            height: 100%;
        }
        #backgroundCanvas { z-index: -1; }
        #gameCanvas { z-index: 0; touch-action: none; }
        #headerLinkContainer {
            position: fixed; 
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10; 
        }
        #headerPalopseeCanvas {
            border-radius: 4px; 
            cursor: pointer;
        }
        #messageBox, #leaderboardButton {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            background-color: #4A90E2; 
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000; 
            font-size: 16px;
        }
        #messageBox { top: 80px; display: none; }
        #leaderboardButton { bottom: 20px; cursor: pointer; }

        /* Leaderboard Modal Styles */
        #leaderboardModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 2000;
            display: none;
            justify-content: center;
            align-items: center;
        }
        #leaderboardContent {
            background-color: white;
            padding: 24px;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            text-align: center;
        }
        #leaderboardContent h2 {
            margin-top: 0;
            font-size: 24px;
        }
        #leaderboardList {
            list-style: none;
            padding: 0;
            margin: 20px 0;
            max-height: 300px;
            overflow-y: auto;
        }
        #leaderboardList li {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            border-radius: 6px;
        }
        #leaderboardList li:nth-child(odd) {
            background-color: #f0f0f0;
        }
        #leaderboardList .player-name {
            font-weight: 600;
        }
         #closeLeaderboard {
            margin-top: 16px;
            padding: 8px 16px;
            border-radius: 8px;
            background-color: #e24a4a;
            color: white;
            cursor: pointer;
            border: none;
        }
    </style>
</head>
<body>

    <canvas id="backgroundCanvas"></canvas>

    <div id="headerLinkContainer">
        <a id="headerLink" href="#" target="_blank" rel="noopener noreferrer">
            <canvas id="headerPalopseeCanvas"></canvas>
        </a>
    </div>

    <canvas id="gameCanvas"></canvas> 

    <div id="messageBox"></div>
    <button id="leaderboardButton">Leaderboard</button>

    <!-- Leaderboard Modal HTML -->
    <div id="leaderboardModal">
        <div id="leaderboardContent">
            <h2>Top Scores</h2>
            <ul id="leaderboardList">
                <!-- Scores will be populated by JavaScript -->
            </ul>
            <button id="closeLeaderboard">Close</button>
        </div>
    </div>

    <!-- Scripts at the end of the body to ensure correct loading order -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.0/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.9.0/firebase-analytics.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.9.0/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, collection, query, orderBy, limit, onSnapshot } from "https://www.gstatic.com/firebasejs/11.9.0/firebase-firestore.js";

        // FIX: Use the user's provided Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDKcumpOoSW3T3qdsNJWFFhje_CCOL-U10",
            authDomain: "palopsee-2d584.firebaseapp.com",
            projectId: "palopsee-2d584",
            storageBucket: "palopsee-2d584.appspot.com", // Corrected storage bucket name
            messagingSenderId: "516105281244",
            appId: "1:516105281244:web:79007aa6c2ae98deac9e19",
            measurementId: "G-E1F0FXCS56"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const analytics = getAnalytics(app);
        const auth = getAuth(app);
        const db = getFirestore(app);

        let currentUser = null;

        // FIX: Simplified authentication to only use anonymous sign-in.
        onAuthStateChanged(auth, (user) => {
            if (user) {
                currentUser = user;
                console.log("Authenticated with user ID:", currentUser.uid);
                listenForLeaderboardUpdates();
            } else {
                signInAnonymously(auth).catch((error) => {
                    console.error("Anonymous sign-in failed:", error);
                });
            }
        });


        // Game Code Starts Here
        const gameCanvas = document.getElementById('gameCanvas');
        const ctx = gameCanvas.getContext('2d');
        const backgroundCanvas = document.getElementById('backgroundCanvas');
        const bgCtx = backgroundCanvas.getContext('2d'); 

        const headerPalopseeCanvas = document.getElementById('headerPalopseeCanvas');
        const headerPalopseeCtx = headerPalopseeCanvas.getContext('2d');
        const headerLink = document.getElementById('headerLink');

        const messageBox = document.getElementById('messageBox');
        const leaderboardButton = document.getElementById('leaderboardButton');
        const leaderboardModal = document.getElementById('leaderboardModal');
        const closeLeaderboardButton = document.getElementById('closeLeaderboard');
        const leaderboardList = document.getElementById('leaderboardList');
        
        let audioInitialized = false;
        let jumpSynth, scoreSynth, gameOverSynth, powerUpSynth;

        function initializeAudio() {
            if (Tone.context.state !== 'running') Tone.start();
            if (audioInitialized) return;
            audioInitialized = true;
            jumpSynth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.01, release: 0.1 } }).toDestination();
            scoreSynth = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.05, sustain: 0, release: 0.1 } }).toDestination();
            gameOverSynth = new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.1 } }).toDestination();
            powerUpSynth = new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 } }).toDestination();
        }
        
        function playJumpSound() { if (audioInitialized) jumpSynth.triggerAttackRelease('C5', '8n', Tone.now()); }
        function playScoreSound() { if (audioInitialized) scoreSynth.triggerAttackRelease('A5', '16n', Tone.now()); }
        function playGameOverSound() { if (audioInitialized) gameOverSynth.triggerAttackRelease('16n', Tone.now()); }
        function playPowerUpSound() { if (audioInitialized) powerUpSynth.triggerAttackRelease('G5', '8n', Tone.now()); }
        
        const customHeaderLinkUrl = "https://palopsee.univer.se/"; 
        const PLAYER_SCALE_HEIGHT = 44;
        const OBSTACLE_SCALE_HEIGHT = 42;
        const POWERUP_SCALE_HEIGHT = 28;
        const HEADER_ICON_SIZE = 40;
        const BACKGROUND_TILE_WIDTH = 200;
        const BACKGROUND_TILE_HEIGHT = 150;
        
        const imageUrls = {
            palopsee: 'https://palopsee.netlify.app/palopsee.png',
            background: 'https://palopsee.netlify.app/background.png',
            alienShip: 'https://palopsee.netlify.app/alien1.png',
            powerUp: 'https://palopsee.netlify.app/star1.png',
            asteroid: 'https://palopsee.netlify.app/asteroid1.gif'
        };

        const assetManager = {
            assets: {}, totalAssets: 0, loadedAssets: 0, onAllAssetsLoaded: null,
            loadAsset(name, src) {
                this.totalAssets++;
                const asset = new Image();
                this.assets[name] = { image: asset, width: 0, height: 0 };
                asset.onload = () => {
                    this.assets[name].width = asset.naturalWidth;
                    this.assets[name].height = asset.naturalHeight;
                    this.assetLoaded();
                };
                asset.onerror = (err) => { 
                    console.error(`Failed to load asset: ${name} at ${src}`, err);
                    this.assetLoaded(); 
                };
                asset.src = src;
            },
            assetLoaded() {
                this.loadedAssets++;
                if (this.loadedAssets === this.totalAssets && typeof this.onAllAssetsLoaded === 'function') {
                    this.onAllAssetsLoaded();
                }
            },
            get(name) { return this.assets[name]; }
        };

        let bgPatternCanvas = null, backgroundPattern = null, backgroundOffsetX = 0; 
        const highScoreKey = 'palopseeGameHighScore_local'; // Local high score key
        let score = 0, previousScoreForSound = 0;
        const scoreMilestoneInterval = 30; 
        let powerUpSpawnedForCurrentMilestone = false; 
        let highScore = 0;
        let gameSpeed = 5, gameSpeedIncreaseFactor = 0.002;
        let gameOver = false, gameStarted = false, assetsReady = false;
        let animationFrameId, gameCanvasWidth, gameCanvasHeight; 

        const gameFont = "'Pixelify Sans', 'Inter', sans-serif"; 

        const player = {
            x: 50, y: 0, width: 0, height: 0,
            dy: 0, jumpStrength: 12, gravity: 0.7,   
            isJumping: false, restingY: 0, isInvincible: false, invincibilityFrames: 0, 
            draw() {
                const palopseeAsset = assetManager.get('palopsee');
                if (!palopseeAsset || !palopseeAsset.image.complete) return;
                if (this.isInvincible && this.invincibilityFrames++ % 10 < 5) {} else {
                    ctx.drawImage(palopseeAsset.image, this.x, this.y, this.width, this.height);
                }
            },
            jump() {
                if (!this.isJumping && !gameOver && gameStarted) { 
                    this.isJumping = true;
                    this.dy = -this.jumpStrength;
                    playJumpSound(); 
                }
            },
            update() {
                if (this.isJumping) {
                    this.y += this.dy;
                    this.dy += this.gravity;
                }
                if (this.y >= this.restingY && this.dy > 0) {
                    this.y = this.restingY;
                    this.isJumping = false;
                    this.dy = 0;
                }
            }
        };

        let obstacles = [], powerUps = []; 

        function getScaledDimensions(assetName, baseHeight) {
            const assetInfo = assetManager.get(assetName);
            if (!assetInfo || !assetInfo.height) return { width: baseHeight, height: baseHeight };
            const aspectRatio = assetInfo.width / assetInfo.height;
            return { width: baseHeight * aspectRatio, height: baseHeight };
        }

        function createObstacle() {
            const isAsteroid = Math.random() < 0.6;
            const assetName = isAsteroid ? 'asteroid' : 'alienShip';
            const assetInfo = assetManager.get(assetName);
            if (!assetInfo || assetInfo.width === 0) return;

            const scaledDims = getScaledDimensions(assetName, OBSTACLE_SCALE_HEIGHT);
            const verticalCenter = gameCanvasHeight / 2;
            let yPos;

            if (isAsteroid) yPos = verticalCenter - scaledDims.height / 2 + (Math.random() * player.height - player.height / 2);
            else { 
                const alienShipClearance = 10;
                yPos = player.restingY - alienShipClearance - scaledDims.height;
                if (yPos < 10) yPos = 10;
            }

            obstacles.push({ 
                x: gameCanvasWidth, y: yPos, width: scaledDims.width, height: scaledDims.height,
                asset: assetInfo,
                draw() { 
                    if (this.asset.image.complete) {
                        ctx.drawImage(this.asset.image, this.x, this.y, this.width, this.height);
                    }
                }, 
                update() { this.x -= gameSpeed; } 
            });
        }

        function createPowerUp() {
            const assetInfo = assetManager.get('powerUp');
            if (!assetInfo || assetInfo.width === 0) return;

            const scaledDims = getScaledDimensions('powerUp', POWERUP_SCALE_HEIGHT);
            const verticalCenter = gameCanvasHeight / 2;
            const yPos = verticalCenter - scaledDims.height / 2 + (Math.random() * (player.height * 2) - player.height);
            
            const pUp = {
                x: gameCanvasWidth, y: yPos, width: scaledDims.width, height: scaledDims.height, image: assetInfo.image,
                draw() { if (this.image.complete) ctx.drawImage(this.image, this.x, this.y, this.width, this.height); },
                update() { this.x -= gameSpeed; }
            };
            if (pUp.y < 20) pUp.y = 20;
            if (pUp.y + pUp.height > gameCanvasHeight - 20) pUp.y = gameCanvasHeight - 20 - pUp.height;
            powerUps.push(pUp);
        }

        function handleObstacles() {
            const spawnMinDistance = gameCanvasWidth * 0.4 + gameSpeed * 10; 
            const spawnRandomDistance = gameCanvasWidth * 0.3;

            if (obstacles.length === 0 || obstacles[obstacles.length - 1].x < gameCanvasWidth - spawnMinDistance - Math.random() * spawnRandomDistance) {
                 if (Math.random() < (0.015 + gameSpeed * 0.0005)) createObstacle();
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].update();
                if ( !player.isInvincible && player.x < obstacles[i].x + obstacles[i].width && player.x + player.width > obstacles[i].x && player.y < obstacles[i].y + obstacles[i].height && player.y + player.height > obstacles[i].y) {
                    setGameOver();
                    return; 
                }
                if (obstacles[i].x + obstacles[i].width < 0) {
                    obstacles.splice(i, 1);
                    score++;
                    if (score > 0 && score % scoreMilestoneInterval === 0 && score !== previousScoreForSound) {
                        playScoreSound();
                        previousScoreForSound = score; 
                    }
                    if (score % scoreMilestoneInterval !== 0) powerUpSpawnedForCurrentMilestone = false;
                }
            }
        }

        function handlePowerUps() {
            if (powerUps.length === 0 && score > 0 && score % scoreMilestoneInterval === 0 && !powerUpSpawnedForCurrentMilestone) {
                createPowerUp();
                powerUpSpawnedForCurrentMilestone = true; 
            }
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const pUp = powerUps[i];
                pUp.update();
                if (player.x < pUp.x + pUp.width && player.x + player.width > pUp.x && player.y < pUp.y + pUp.height && player.y + player.height > pUp.y) {
                    player.isInvincible = true;
                    player.invincibilityFrames = 0; 
                    playPowerUpSound();
                    powerUps.splice(i, 1); 
                    setTimeout(() => { player.isInvincible = false; }, 5000); 
                }
                if (pUp.x + pUp.width < 0) powerUps.splice(i, 1);
            }
        }
        
        function createBackgroundPatternTile() {
            const bgInfo = assetManager.get('background');
            if (bgInfo && bgInfo.image.complete) {
                bgPatternCanvas = document.createElement("canvas");
                bgPatternCanvas.width = BACKGROUND_TILE_WIDTH;
                bgPatternCanvas.height = BACKGROUND_TILE_HEIGHT;
                const pCtx = bgPatternCanvas.getContext("2d");
                pCtx.drawImage(bgInfo.image, 0, 0, bgPatternCanvas.width, bgPatternCanvas.height);
                createActualPattern();
            } else bgPatternCanvas = null;
        }
        
        function createActualPattern(){ 
            if (bgPatternCanvas && bgCtx) backgroundPattern = bgCtx.createPattern(bgPatternCanvas, "repeat");
            else backgroundPattern = null;
        }

        function drawScrollingFullScreenBackground(){ 
            if (!bgCtx) return;
            bgCtx.clearRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
            if (backgroundPattern && bgPatternCanvas) {
                bgCtx.save();
                bgCtx.globalAlpha = 0.1;
                let pOffsetX = backgroundOffsetX % bgPatternCanvas.width;
                bgCtx.translate(pOffsetX, 0);
                bgCtx.fillStyle = backgroundPattern;
                bgCtx.fillRect(-pOffsetX, 0, backgroundCanvas.width + bgPatternCanvas.width, backgroundCanvas.height); 
                bgCtx.restore();
            } else {
                bgCtx.fillStyle = '#ffffff';
                bgCtx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
            }
        }
        
        function showMessage(msg, duration = 3000) {
            messageBox.textContent = msg;
            messageBox.style.display = "block";
            setTimeout(() => { messageBox.style.display = "none" }, duration);
        }
        
        function drawHeaderPalopsee() {
            if (!headerPalopseeCtx) return;
            const pAsset = assetManager.get('palopsee');
            headerPalopseeCanvas.width = HEADER_ICON_SIZE;
            headerPalopseeCanvas.height = HEADER_ICON_SIZE;
            headerPalopseeCtx.clearRect(0, 0, HEADER_ICON_SIZE, HEADER_ICON_SIZE);
            if (pAsset && pAsset.image.complete) {
                headerPalopseeCtx.drawImage(pAsset.image, 0, 0, HEADER_ICON_SIZE, HEADER_ICON_SIZE);
            }
        }

        async function setGameOver() {
            gameOver = true;
            gameStarted = false;
            player.isInvincible = false;

            if (score > highScore) {
                highScore = score;
                localStorage.setItem(highScoreKey, highScore);
                await submitScore(score);
            }
            playGameOverSound(); 
        }

        async function submitScore(newScore) {
            if (!currentUser) return;

            const userDocRef = doc(db, "scores", currentUser.uid);
            const userDoc = await getDoc(userDocRef);
            const existingScore = userDoc.exists() ? userDoc.data().score : 0;
            
            if (newScore > existingScore) {
                let name = userDoc.exists() ? userDoc.data().name : null;
                if (!name) {
                    name = prompt("New high score! Enter your name for the leaderboard:", "Player");
                    if (!name) name = "Anonymous"; // Default name if prompt is cancelled
                }
                await setDoc(userDocRef, {
                    name: name,
                    score: newScore,
                    userId: currentUser.uid
                }, { merge: true });
                showMessage("High score saved to leaderboard!");
            }
        }

        function resetGame() {
            score = 0; previousScoreForSound = 0; 
            powerUpSpawnedForCurrentMilestone = false; 
            gameSpeed = 5; gameOver = false; gameStarted = false; 
            obstacles = []; powerUps = []; 
            player.dy = 0; player.isJumping = false; player.isInvincible = false;
            player.y = player.restingY;
            messageBox.style.display = 'none';
        }

        function gameLoop() {
            animationFrameId = requestAnimationFrame(gameLoop);

            backgroundOffsetX -= gameSpeed * (gameStarted && !gameOver ? 1 : 0);
            drawScrollingFullScreenBackground(); 
            ctx.clearRect(0, 0, gameCanvasWidth, gameCanvasHeight); 
            
            if (gameStarted && !gameOver) {
                player.update();
                handleObstacles(); 
                handlePowerUps();
                gameSpeed += gameSpeedIncreaseFactor;
            }
            
            player.draw();
            obstacles.forEach(obs => obs.draw());
            powerUps.forEach(pUp => pUp.draw());

            ctx.font = `16px ${gameFont}`; 
            ctx.fillStyle = '#333333'; 
            ctx.textAlign = 'left';
            ctx.fillText(`Score: ${score}`, 10, 25);
            ctx.fillText(`Local High Score: ${highScore}`, 10, 50);

            if (gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.75)'; 
                ctx.fillRect(0, 0, gameCanvasWidth, gameCanvasHeight); 
                ctx.font = `40px ${gameFont}`; 
                ctx.fillStyle = '#FFFFFF'; 
                ctx.textAlign = 'center';
                ctx.fillText('Game Over!', gameCanvasWidth / 2, gameCanvasHeight / 2 - 30);
                ctx.font = `20px ${gameFont}`; 
                ctx.fillText(`Score: ${score}`, gameCanvasWidth / 2, gameCanvasHeight / 2 + 10);
                ctx.fillText(`High Score: ${highScore}`, gameCanvasWidth / 2, gameCanvasHeight / 2 + 40);
                ctx.font = `16px ${gameFont}`; 
                ctx.fillText('Tap or Press Space/Up to Restart', gameCanvasWidth / 2, gameCanvasHeight / 2 + 70);
            } else if (!gameStarted && assetsReady) {
                ctx.font = `20px ${gameFont}`; 
                ctx.textAlign = 'center';
                const promptText = 'Tap Screen or Press Space/Up to Start!';
                const textMetrics = ctx.measureText(promptText);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.fillRect(gameCanvas.width / 2 - textMetrics.width / 2 - 10, gameCanvas.height - 80, textMetrics.width + 20, 30);
                ctx.fillStyle = '#000000';
                ctx.fillText(promptText, gameCanvas.width / 2, gameCanvas.height - 60);
            }
        }

        function assetsReadyCallback() {
            assetsReady = true;
            const scaledPlayerDims = getScaledDimensions('palopsee', PLAYER_SCALE_HEIGHT);
            player.width = scaledPlayerDims.width;
            player.height = scaledPlayerDims.height;
            resizeAndRedrawAll(); 
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop();
            if (!gameStarted && !gameOver) showMessage('Ready to Fly!', 2000);
        }

        function startGameActions() {
            if (!audioInitialized) initializeAudio();
            if (gameOver) {
                resetGame();
                return;
            }
            if (!gameStarted && assetsReady) {
                gameStarted = true;
                score = 0;
                gameSpeed = 5;
                player.jump();
            } else if (gameStarted) {
                 player.jump();
            }
        }

        function listenForLeaderboardUpdates() {
            const scoresQuery = query(collection(db, "scores"), orderBy("score", "desc"), limit(10));
            onSnapshot(scoresQuery, (snapshot) => {
                leaderboardList.innerHTML = ''; // Clear previous list
                snapshot.forEach((doc) => {
                    const data = doc.data();
                    const li = document.createElement('li');
                    li.innerHTML = `<span class="player-name">${data.name}</span><span>${data.score}</span>`;
                    leaderboardList.appendChild(li);
                });
            });
        }

        window.addEventListener('keydown', (e) => { if (e.code === 'Space' || e.code === 'ArrowUp') startGameActions(); });
        document.body.addEventListener('touchstart', (e) => {
            if (e.target.closest('#headerLinkContainer') || e.target.closest('#leaderboardButton')) return; 
            startGameActions(); 
        }, { passive: false }); 

        leaderboardButton.addEventListener('click', () => {
            leaderboardModal.style.display = 'flex';
        });

        closeLeaderboardButton.addEventListener('click', () => {
            leaderboardModal.style.display = 'none';
        });

        function resizeAndRedrawAll() { 
            gameCanvasWidth = window.innerWidth; 
            gameCanvasHeight = window.innerHeight;
            backgroundCanvas.width = gameCanvasWidth;
            backgroundCanvas.height = gameCanvasHeight;
            gameCanvas.width = gameCanvasWidth;
            gameCanvas.height = gameCanvasHeight;

            player.restingY = gameCanvasHeight / 2 - player.height / 2;
            if (!gameStarted) player.y = player.restingY;
            
            createBackgroundPatternTile();
            drawHeaderPalopsee();
        }
        
        window.addEventListener('resize', resizeAndRedrawAll);

        function initGame() {
            headerLink.href = customHeaderLinkUrl; 
            const savedHighScore = localStorage.getItem(highScoreKey);
            if (savedHighScore) highScore = parseInt(savedHighScore, 10);

            assetManager.onAllAssetsLoaded = assetsReadyCallback;
            Object.keys(imageUrls).forEach(name => assetManager.loadAsset(name, imageUrls[name]));
        }

        initGame(); 
    </script>

<script type="module">
  // Import the functions you need from the SDKs you need
  import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.0/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.9.0/firebase-analytics.js";
  // TODO: Add SDKs for Firebase products that you want to use
  // https://firebase.google.com/docs/web/setup#available-libraries

  // Your web app's Firebase configuration
  // For Firebase JS SDK v7.20.0 and later, measurementId is optional
  const firebaseConfig = {
    apiKey: "AIzaSyDKcumpOoSW3T3qdsNJWFFhje_CCOL-U10",
    authDomain: "palopsee-2d584.firebaseapp.com",
    projectId: "palopsee-2d584",
    storageBucket: "palopsee-2d584.firebasestorage.app",
    messagingSenderId: "516105281244",
    appId: "1:516105281244:web:79007aa6c2ae98deac9e19",
    measurementId: "G-E1F0FXCS56"
  };

  // Initialize Firebase
  const app = initializeApp(firebaseConfig);
  const analytics = getAnalytics(app);
</script>
    
</body>
</html>
