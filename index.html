<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Palopsee's Space Run</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Pixelify+Sans:wght@400;600;700&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            font-family: 'Pixelify Sans', 'Inter', sans-serif; 
            margin: 0;
            color: #333; 
            overscroll-behavior-y: contain; 
            transition: background-color 0.3s ease, color 0.3s ease;
            overflow: hidden; 
            height: 100vh; 
            width: 100vw;
        }
        #backgroundCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%; 
            height: 100%;
            z-index: -1; 
        }
        #headerLinkContainer {
            position: fixed; 
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10; 
        }
        #headerPalopseeCanvas {
            border-radius: 4px; 
            cursor: pointer;
        }
        canvas#gameCanvas { 
            position: fixed;
            top: 0;
            left: 0;
            width: 100%; 
            height: 100%;
            touch-action: none; 
            display: block; 
            z-index: 0; 
        }
        #messageBox {
            position: fixed;
            top: 80px; 
            left: 50%;
            transform: translateX(-50%);
            background-color: #4A90E2; 
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000; 
            display: none; 
            font-size: 16px;
            font-family: 'Pixelify Sans', 'Inter', sans-serif; 
        }
        .light-theme {
            background-color: #ffffff; 
            color: #333333;
        }
        .dark-theme {
            background-color: #121212; 
            color: #DDDDDD;
        }

        /* --- NEW: Theme Toggle Button Styles --- */
        #theme-toggle {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 1001; /* Ensure it's above other elements */
            cursor: pointer;
            background-color: rgba(128, 128, 128, 0.2);
            border-radius: 50%;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
        }
        #theme-toggle:hover {
            background-color: rgba(128, 128, 128, 0.4);
        }
        #theme-toggle svg {
            width: 24px;
            height: 24px;
        }
        .light-theme #sun-icon { display: none; }
        .light-theme #moon-icon { display: block; fill: #333; }
        .dark-theme #sun-icon { display: block; fill: #FFF; }
        .dark-theme #moon-icon { display: none; }
        /* --- END: New Styles --- */
    </style>
</head>
<body>

    <canvas id="backgroundCanvas"></canvas>

    <div id="headerLinkContainer">
        <a id="headerLink" href="#" target="_blank" rel="noopener noreferrer">
            <canvas id="headerPalopseeCanvas"></canvas>
        </a>
    </div>

    <canvas id="gameCanvas"></canvas> 

    <div id="messageBox"></div>

    <!-- NEW: Theme Toggle Button HTML -->
    <div id="theme-toggle" title="Toggle Theme">
        <svg viewBox="0 0 24 24">
            <!-- Moon Icon -->
            <path id="moon-icon" d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path>
            <!-- Sun Icon -->
            <path id="sun-icon" d="M12 3a1 1 0 011 1v2a1 1 0 11-2 0V4a1 1 0 011-1zM4.929 4.929a1 1 0 011.414 0l1.414 1.414a1 1 0 01-1.414 1.414L4.929 6.343a1 1 0 010-1.414zM21 12a1 1 0 01-1 1h-2a1 1 0 110-2h2a1 1 0 011 1zM16.243 16.243a1 1 0 011.414 0l1.414 1.414a1 1 0 01-1.414 1.414l-1.414-1.414a1 1 0 010-1.414zM12 19a1 1 0 011 1v2a1 1 0 11-2 0v-2a1 1 0 011-1zM7.757 16.243a1 1 0 010 1.414l-1.414 1.414a1 1 0 01-1.414-1.414l1.414-1.414a1 1 0 011.414 0zM4 12a1 1 0 01-1 1H1a1 1 0 110-2h2a1 1 0 011 1zM7.757 7.757a1 1 0 010-1.414L6.343 4.929a1 1 0 111.414-1.414l1.414 1.414a1 1 0 01-1.414 1.414zM12 7a5 5 0 100 10 5 5 0 000-10z"></path>
        </svg>
    </div>
    <!-- END: New HTML -->


    <script>
        const gameCanvas = document.getElementById('gameCanvas');
        const ctx = gameCanvas.getContext('2d');
        const backgroundCanvas = document.getElementById('backgroundCanvas');
        const bgCtx = backgroundCanvas.getContext('2d'); 

        const headerPalopseeCanvas = document.getElementById('headerPalopseeCanvas');
        const headerPalopseeCtx = headerPalopseeCanvas.getContext('2d');
        const headerLink = document.getElementById('headerLink');
        const headerLinkContainer = document.getElementById('headerLinkContainer');


        const messageBox = document.getElementById('messageBox');
        const bodyElement = document.body;
        const themeToggle = document.getElementById('theme-toggle'); // NEW: Get theme toggle button

        // --- Sound Effects Setup (Tone.js) ---
        let audioInitialized = false;
        let jumpSynth, scoreSynth, gameOverSynth, powerUpSynth;

        function initializeAudio() {
            if (Tone.context.state !== 'running') {
                Tone.start(); 
            }
            jumpSynth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.01, release: 0.1 } }).toDestination();
            scoreSynth = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.05, sustain: 0, release: 0.1 } }).toDestination();
            gameOverSynth = new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.1 } }).toDestination();
            powerUpSynth = new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 } }).toDestination();
            audioInitialized = true;
        }
        
        function playJumpSound() { if (audioInitialized) {jumpSynth.volume.value = -12; jumpSynth.triggerAttackRelease('C5', '8n', Tone.now());} }
        function playScoreSound() { if (audioInitialized) {scoreSynth.volume.value = -18; scoreSynth.triggerAttackRelease('A5', '16n', Tone.now());} }
        function playGameOverSound() { if (audioInitialized) {gameOverSynth.volume.value = -8; gameOverSynth.triggerAttackRelease('16n', Tone.now());} }
        function playPowerUpSound() { if (audioInitialized) {powerUpSynth.volume.value = -10; powerUpSynth.triggerAttackRelease('G5', '8n', Tone.now());} }
        // --- End Sound Effects Setup ---


        // --- Theme Colors ---
        const themes = {
            light: { bodyBg: '#ffffff', bodyText: '#333333', canvasFallbackBg: '#ffffff', scoreText: '#333333', promptText: '#000000', promptBg: 'rgba(255, 255, 255, 0.7)', gameOverOverlay: 'rgba(0, 0, 0, 0.75)', gameOverMainText: '#FFFFFF', gameOverSubText: '#FFFFFF' },
            dark: { bodyBg: '#121212', bodyText: '#DDDDDD', canvasFallbackBg: '#222222', scoreText: '#DDDDDD', promptText: '#FFFFFF', promptBg: 'rgba(0, 0, 0, 0.5)', gameOverOverlay: 'rgba(255, 255, 255, 0.15)', gameOverMainText: '#FFFFFF', gameOverSubText: '#EEEEEE' }
        };
        let currentTheme = themes.light; 
        let isDarkMode = false; 

        // --- Customizable Link URL ---
        let customHeaderLinkUrl = "https://palopsee.univer.se/"; 
        // --- End Customizable Link URL ---
        
        // --- Asset URLs ---
        const imageUrls = {
            palopsee: 'https://palopsee.netlify.app/palopsee.png',
            palopseeDark: 'https://palopsee.netlify.app/palopsee-modified.png',
            background: 'https://palopsee.netlify.app/background.png',
            asteroid: '/alien1.png',
            powerUp: '/star1.png'
        };

        const gifUrls = {
            alienShip: '/asteroid1.gif' // The alien ship is now an animated GIF
        };

        // --- Define Target Sizes for Game Elements ---
        const playerTargetWidth = 50; 
        const playerTargetHeight = 50;
        const asteroidTargetWidth = 32; 
        const asteroidTargetHeight = 32;
        const alienShipTargetWidth = 48; 
        const alienShipTargetHeight = 24;
        const powerUpTargetWidth = 24;   
        const powerUpTargetHeight = 24;
        const headerPalopseeTargetWidth = 40; 
        const headerPalopseeTargetHeight = 40;
        const backgroundTileWidth = 200; 
        const backgroundTileHeight = 150; 

        // --- Asset Manager for Loading Images and GIFs ---
        const assetManager = {
            assets: {},
            totalAssets: 0,
            loadedAssets: 0,
            onAllAssetsLoaded: null,

            loadAsset(name, src) {
                this.totalAssets++;
                const asset = new Image(); // Use Image object for both PNG and GIF
                asset.src = src;
                asset.onload = () => this.assetLoaded(name, src);
                asset.onerror = () => {
                    console.error(`Failed to load asset: ${name} at ${src}`);
                    this.assetLoaded(name, src); // Still count as loaded to not halt the game
                };
                this.assets[name] = asset;
            },

            assetLoaded(name, src) {
                this.loadedAssets++;
                console.log(`Loaded ${name} from ${src}`);
                if (this.loadedAssets === this.totalAssets && typeof this.onAllAssetsLoaded === 'function') {
                    this.onAllAssetsLoaded();
                }
            },

            get(name) {
                return this.assets[name];
            }
        };


        let bgPatternCanvas = null; 
        let backgroundPattern = null; 
        let backgroundOffsetX = 0; 
        
        // Game variables
        const highScoreKey = 'palopseeGameHighScore'; 
        let score = 0;
        let previousScoreForSound = 0; 
        const scoreMilestoneInterval = 30; 
        let powerUpSpawnedForCurrentMilestone = false; 
        let highScore = 0;
        let gameSpeed = 5;
        let gameSpeedIncreaseFactor = 0.002;
        let gameOver = false;
        let gameStarted = false;
        let assetsReady = false;
        let animationFrameId;

        let gameCanvasWidth; 
        let gameCanvasHeight; 

        const gameFont = "'Pixelify Sans', 'Inter', sans-serif"; 

        // Player (Palopsee) properties
        const player = {
            x: 50,
            y: 0, 
            width: playerTargetWidth,  
            height: playerTargetHeight, 
            dy: 0, 
            jumpStrength: 12, 
            gravity: 0.7,   
            isJumping: false,
            restingY: 0,
            isInvincible: false, 
            invincibilityFrames: 0, 
            draw() {
                const palopseeAsset = isDarkMode ? assetManager.get('palopseeDark') : assetManager.get('palopsee');

                if (palopseeAsset && palopseeAsset.complete && palopseeAsset.naturalWidth > 0) {
                    if (this.isInvincible) {
                        this.invincibilityFrames++;
                        if (this.invincibilityFrames % 10 < 5) return; 
                    }
                    ctx.drawImage(palopseeAsset, this.x, this.y, this.width, this.height);
                } else {
                    ctx.fillStyle = currentTheme.scoreText; 
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
            },
            jump() {
                // Prevent jumping from theme toggle clicks
                if (event && event.target === themeToggle) return;
                if (!this.isJumping && !gameOver && gameStarted) { 
                    this.isJumping = true;
                    this.dy = -this.jumpStrength;
                    playJumpSound(); 
                }
            },
            update() {
                if (this.isJumping) {
                    this.y += this.dy;
                    this.dy += this.gravity;
                }
                if (this.y >= this.restingY && this.dy > 0) {
                    this.y = this.restingY;
                    this.isJumping = false;
                    this.dy = 0;
                }
            }
        };

        let obstacles = [];
        let powerUps = []; 

        function createObstacle() {
            const obstacleType = Math.random() < 0.6 ? 'asteroid' : 'alienShip'; 
            let img, width, height, yPos;
            const verticalCenter = gameCanvasHeight / 2;

            if (obstacleType === 'asteroid') {
                img = assetManager.get('asteroid');
                width = asteroidTargetWidth; 
                height = asteroidTargetHeight; 
                yPos = verticalCenter - height / 2 + (Math.random() * player.height - player.height / 2);
            } else { // alienShip
                img = assetManager.get('alienShip');
                width = alienShipTargetWidth; 
                height = alienShipTargetHeight; 
                const alienShipClearance = 10;
                yPos = player.restingY - alienShipClearance - height;
                if (yPos < 10) yPos = 10;
            }

            obstacles.push({ 
                x: gameCanvasWidth, y: yPos, width, height, type: obstacleType, image: img, 
                draw() { 
                    if (this.image && this.image.complete && this.image.naturalWidth > 0) {
                        ctx.drawImage(this.image, this.x, this.y, this.width, this.height); 
                    } else {
                        ctx.fillStyle = (this.type === 'asteroid') ? '#A9A9A9' : '#90EE90'; 
                        ctx.fillRect(this.x, this.y, this.width, this.height);
                    }
                }, 
                update() { this.x -= gameSpeed; } 
            });
        }

        function createPowerUp() {
            const verticalCenter = gameCanvasHeight / 2;
            const newPowerUp = {
                x: gameCanvasWidth,
                y: verticalCenter - powerUpTargetHeight / 2 + (Math.random() * (player.height * 2) - player.height), 
                width: powerUpTargetWidth,
                height: powerUpTargetHeight,
                image: assetManager.get('powerUp'),
                draw() { 
                     if (this.image && this.image.complete && this.image.naturalWidth > 0) {
                        ctx.drawImage(this.image, this.x, this.y, this.width, this.height); 
                     } else {
                        ctx.fillStyle = '#FFD700'; 
                        ctx.fillRect(this.x, this.y, this.width, this.height);
                     }
                },
                update() { this.x -= gameSpeed; }
            };
            if (newPowerUp.y < 20) newPowerUp.y = 20;
            if (newPowerUp.y + newPowerUp.height > gameCanvasHeight - 20) newPowerUp.y = gameCanvasHeight - 20 - newPowerUp.height;
            powerUps.push(newPowerUp);
        }

        function handleObstacles() {
            const spawnMinDistance = gameCanvasWidth * 0.4 + gameSpeed * 10; 
            const spawnRandomDistance = gameCanvasWidth * 0.3;

            if (obstacles.length === 0 || obstacles[obstacles.length - 1].x < gameCanvasWidth - spawnMinDistance - Math.random() * spawnRandomDistance) {
                 if (Math.random() < (0.015 + gameSpeed * 0.0005) && gameStarted) { 
                    createObstacle();
                 }
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                obs.update();
                obs.draw();

                if ( !player.isInvincible &&
                    player.x < obs.x + obs.width && player.x + player.width > obs.x &&
                    player.y < obs.y + obs.height && player.y + player.height > obs.y
                ) {
                    setGameOver();
                    return; 
                }

                if (obs.x + obs.width < 0) {
                    obstacles.splice(i, 1);
                    if (!gameOver) {
                        score++;
                        if (score > 0 && score % scoreMilestoneInterval === 0 && score !== previousScoreForSound) {
                            playScoreSound();
                            previousScoreForSound = score; 
                        }
                        if (score % scoreMilestoneInterval !== 0) {
                            powerUpSpawnedForCurrentMilestone = false;
                        }
                    }
                }
            }
        }

        function handlePowerUps() {
            if (gameStarted && powerUps.length === 0 && 
                score > 0 && score % scoreMilestoneInterval === 0 && 
                !powerUpSpawnedForCurrentMilestone) {
                createPowerUp();
                powerUpSpawnedForCurrentMilestone = true; 
            }

            for (let i = powerUps.length - 1; i >= 0; i--) {
                const pUp = powerUps[i];
                pUp.update();
                pUp.draw();

                if (
                    player.x < pUp.x + pUp.width && player.x + player.width > pUp.x &&
                    player.y < pUp.y + pUp.height && player.y + player.height > pUp.y
                ) {
                    player.isInvincible = true;
                    player.invincibilityFrames = 0; 
                    playPowerUpSound();
                    powerUps.splice(i, 1); 
                    setTimeout(() => { player.isInvincible = false; }, 5000); 
                }

                if (pUp.x + pUp.width < 0) {
                    powerUps.splice(i, 1); 
                }
            }
        }
        
        function createBackgroundPatternTile() {
            const bgImg = assetManager.get('background');
            if (bgImg && bgImg.complete && bgImg.naturalWidth > 0) {
                bgPatternCanvas = document.createElement("canvas");
                bgPatternCanvas.width = backgroundTileWidth;
                bgPatternCanvas.height = backgroundTileHeight;
                const patternCtx = bgPatternCanvas.getContext("2d");
                patternCtx.drawImage(bgImg, 0, 0, backgroundTileWidth, backgroundTileHeight);
            } else {
                bgPatternCanvas = null;
            }
        }
        
        function createActualPattern(){ 
            if (bgPatternCanvas && bgCtx) {
                backgroundPattern = bgCtx.createPattern(bgPatternCanvas, "repeat");
            } else {
                backgroundPattern = null;
            }
        }

        function drawScrollingFullScreenBackground(){ 
            if (!bgCtx) return;
            bgCtx.clearRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
            
            if (backgroundPattern) {
                bgCtx.save();
                bgCtx.globalAlpha = 0.1;
                let patternOffsetX = backgroundOffsetX % bgPatternCanvas.width;
                if (patternOffsetX > 0) patternOffsetX -= bgPatternCanvas.width;
                bgCtx.translate(patternOffsetX, 0);
                bgCtx.fillStyle = backgroundPattern;
                bgCtx.fillRect(0, 0, backgroundCanvas.width + bgPatternCanvas.width, backgroundCanvas.height); 
                bgCtx.restore();
            } else {
                bgCtx.fillStyle = currentTheme.canvasFallbackBg;
                bgCtx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
            }
        }
        
        function showMessage(msg, duration = 3000) {
            messageBox.textContent = msg;
            messageBox.style.display = "block";
            setTimeout(() => { messageBox.style.display = "none" }, duration);
        }
        
        function drawHeaderPalopsee() {
            if (!headerPalopseeCtx) return;
            
            const headerImg = isDarkMode ? assetManager.get('palopseeDark') : assetManager.get('palopsee');
            headerPalopseeCtx.clearRect(0, 0, headerPalopseeTargetWidth, headerPalopseeTargetHeight);

            if (headerImg && headerImg.complete && headerImg.naturalWidth > 0) {
                 headerPalopseeCtx.drawImage(headerImg, 0, 0, headerPalopseeTargetWidth, headerPalopseeTargetHeight);
            } else {
                 headerPalopseeCtx.fillStyle = currentTheme.canvasFallbackBg;
                 headerPalopseeCtx.fillRect(0, 0, headerPalopseeTargetWidth, headerPalopseeTargetHeight);
            }
        }


        function setGameOver() {
            gameOver = true;
            gameStarted = false;
            player.isInvincible = false; 
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            playGameOverSound(); 
            
            ctx.fillStyle = currentTheme.gameOverOverlay; 
            ctx.fillRect(0, 0, gameCanvasWidth, gameCanvasHeight); 
            ctx.font = `40px ${gameFont}`; 
            ctx.fillStyle = currentTheme.gameOverMainText; 
            ctx.textAlign = 'center';
            ctx.fillText('Game Over!', gameCanvasWidth / 2, gameCanvasHeight / 2 - 30);
            ctx.font = `20px ${gameFont}`; 
            ctx.fillStyle = currentTheme.gameOverSubText; 
            ctx.fillText(`Score: ${score}`, gameCanvasWidth / 2, gameCanvasHeight / 2 + 10);
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem(highScoreKey, highScore); 
                ctx.fillText(`New High Score! ${highScore}`, gameCanvasWidth / 2, gameCanvasHeight / 2 + 40);
            } else {
                ctx.fillText(`High Score: ${highScore}`, gameCanvasWidth / 2, gameCanvasHeight / 2 + 40);
            }

            ctx.font = `16px ${gameFont}`; 
            ctx.fillText('Tap or Press Space/Up to Restart', gameCanvasWidth / 2, gameCanvasHeight / 2 + 70);
        }

        function resetGame() {
            score = 0;
            previousScoreForSound = 0; 
            powerUpSpawnedForCurrentMilestone = false; 
            gameSpeed = 5; 
            gameOver = false;
            gameStarted = false; 
            obstacles = [];
            powerUps = []; 
            player.dy = 0;
            player.isJumping = false;
            player.isInvincible = false;
            
            resizeAndRedrawAll();
            messageBox.style.display = 'none';
        }
        
        function gameLoop() {
            if (gameOver) return;

            backgroundOffsetX -= gameSpeed;
            drawScrollingFullScreenBackground(); 

            ctx.clearRect(0, 0, gameCanvasWidth, gameCanvasHeight); 
            player.update();
            player.draw(); 
            handleObstacles(); 
            handlePowerUps();  
            
            ctx.font = `16px ${gameFont}`; 
            ctx.fillStyle = currentTheme.scoreText; 
            ctx.textAlign = 'left';
            ctx.fillText(`Score: ${score}`, 10, 25); 

            gameSpeed += gameSpeedIncreaseFactor; 
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function assetsReadyCallback() {
            assetsReady = true;
            createBackgroundPatternTile();
            createActualPattern();
            drawHeaderPalopsee();
            resizeAndRedrawAll();
            if (!gameStarted && !gameOver) {
                showMessage('Ready to Fly!', 2000);
            }
        }

        function startGameActions(event) {
            // NEW: Prevent starting game if the theme toggle was the target
            if (event && event.target.closest('#theme-toggle')) {
                return;
            }
            if (!audioInitialized) initializeAudio();
            if (gameOver) { resetGame(); return; }
            if (!gameStarted && assetsReady) {
                gameStarted = true;
                if (animationFrameId) cancelAnimationFrame(animationFrameId); 
                gameLoop();
            }
            player.jump();
        }

        window.addEventListener('keydown', (e) => { if ((e.code === 'Space' || e.code === 'ArrowUp')) { e.preventDefault(); startGameActions(e); } });
        
        document.body.addEventListener('touchstart', (e) => {
            if (e.target.closest('#headerLinkContainer')) return; 
            e.preventDefault(); 
            startGameActions(e); 
        }, { passive: false }); 

        // --- UPDATED: Theme Functions ---
        function applyTheme(isDark) { 
            isDarkMode = isDark; 
            currentTheme = isDarkMode ? themes.dark : themes.light; 
            bodyElement.className = isDarkMode ? 'dark-theme' : 'light-theme'; 
            if(assetsReady) {
                drawHeaderPalopsee(); 
                resizeAndRedrawAll(); 
            }
        }

        function toggleTheme() {
            applyTheme(!isDarkMode);
        }

        themeToggle.addEventListener('click', toggleTheme);
        // --- END: Updated Theme Functions ---

        function resizeAndRedrawAll() { 
            backgroundCanvas.width = window.innerWidth;
            backgroundCanvas.height = window.innerHeight;
            if (assetManager.get('background')?.complete) {
                 createBackgroundPatternTile();
                 createActualPattern(); 
            }
            
            gameCanvas.width = window.innerWidth;
            gameCanvas.height = window.innerHeight;
            gameCanvasWidth = gameCanvas.width; 
            gameCanvasHeight = gameCanvas.height;

            player.restingY = gameCanvasHeight / 2 - player.height / 2;
            if (!player.isJumping || !gameStarted) {
                 player.y = player.restingY;
            }
            
            drawScrollingFullScreenBackground();
            ctx.clearRect(0, 0, gameCanvasWidth, gameCanvasHeight);

            if (assetsReady) {
                player.draw();
                obstacles.forEach(o => o.draw());
                powerUps.forEach(p => p.draw());

                ctx.font = `16px ${gameFont}`;
                ctx.fillStyle = currentTheme.scoreText;
                ctx.textAlign = 'left';
                ctx.fillText(`Score: ${score}`, 10, 25);
            }

            if (gameOver) { 
                setGameOver(); 
            } else if (!gameStarted && assetsReady) { 
                ctx.font = `20px ${gameFont}`; 
                ctx.textAlign = 'center';
                const promptText = 'Tap Screen or Press Space/Up to Start!';
                const textMetrics = ctx.measureText(promptText);
                ctx.fillStyle = currentTheme.promptBg; 
                ctx.fillRect(gameCanvas.width / 2 - textMetrics.width / 2 - 10, gameCanvas.height / 2 - 20, textMetrics.width + 20, 30);
                ctx.fillStyle = currentTheme.promptText; 
                ctx.fillText(promptText, gameCanvas.width / 2, gameCanvas.height / 2);
            } else if (!assetsReady) { 
                 ctx.font = `20px ${gameFont}`; 
                 ctx.textAlign = 'center';
                 ctx.fillStyle = currentTheme.promptText; 
                 ctx.fillText('Loading Assets...', gameCanvas.width / 2, gameCanvas.height / 2);
            }
            if(assetsReady) drawHeaderPalopsee(); 
        }
        
        window.addEventListener('resize', resizeAndRedrawAll);

        function initGame() {
            headerLink.href = customHeaderLinkUrl; 
            headerPalopseeCanvas.width = headerPalopseeTargetWidth;
            headerPalopseeCanvas.height = headerPalopseeTargetHeight;

            const savedHighScore = localStorage.getItem(highScoreKey);
            if (savedHighScore) { highScore = parseInt(savedHighScore, 10); }

            player.width = playerTargetWidth;
            player.height = playerTargetHeight;

            assetManager.onAllAssetsLoaded = assetsReadyCallback;
            
            Object.keys(imageUrls).forEach(name => assetManager.loadAsset(name, imageUrls[name]));
            Object.keys(gifUrls).forEach(name => assetManager.loadAsset(name, gifUrls[name]));

            // Sets the initial theme based on system preference
            const darkModeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
            applyTheme(darkModeMediaQuery.matches); 
        }

        initGame(); 
    </script>
</body>
</html>
